from __future__ import annotations

from copy import deepcopy
from dataclasses import dataclass
from importlib import resources
from textwrap import dedent
from time import ctime
from typing import Any, Iterable, Optional, Union
from warnings import warn

import pandas as pd
from typing_extensions import Self

from instamatic import config
from instamatic._collections import partial_formatter
from instamatic._typing import AnyPath


class PetsInputWarning(UserWarning):
    pass


class PetsKeywords:
    """Read PETS2 field metadata as read from the PETS2 manual."""

    def __init__(self, table: pd.DataFrame) -> None:
        table.fillna({'end': 'optional'}, inplace=True)
        self.table = table

    @classmethod
    def from_file(cls, path: AnyPath) -> Self:
        return cls(pd.read_csv(path, index_col='field'))

    @property
    def list(self) -> list[str]:
        return self.table.index.values.tolist()

    def find(self, text: str) -> set[str]:
        firsts = {t.strip().split()[0].lower() for t in text.splitlines() if t.strip()}
        return firsts.intersection(self.list)


with resources.files('instamatic.processing').joinpath('PETS_input_keywords.csv').open() as f:
    pets_keywords = PetsKeywords.from_file(f)  # noqa: default keywords read at import


@dataclass
class PetsInputElement:
    """Store metadata for a single PETS input element."""

    keywords: list[str]
    values: list[Any]
    string: Optional[str] = None

    def __str__(self):
        return self.string if self.string is not None else self.build_string()

    @classmethod
    def from_any(cls, keyword_or_text: str, values: Optional[list[Any]] = None) -> Self:
        keywords = pets_keywords.find(keyword_or_text)
        if len(keywords) == 1 and values is not None:
            return cls([keywords.pop()], values)
        return cls(keywords=list(keywords), values=[], string=keyword_or_text)

    @classmethod
    def list_from_text(cls, text: str) -> list[Self]:
        """Split a text with many commands it into `list[PetsInputElement]`"""
        lines = text.splitlines()
        firsts = [ts.split()[0].lower() if (ts := t.strip()) else '' for t in lines]

        def split2blocks(start: int) -> list[str]:
            if start >= len(lines):
                return []
            if firsts[start] not in pets_keywords.list:
                return [lines[start]] + split2blocks(start + 1)
            if pets_keywords.table.at[firsts[start], 'end'] == 'false':
                return [lines[start]] + split2blocks(start + 1)
            try:
                end = firsts.index('end' + firsts[start], start)
            except ValueError:
                if pets_keywords.table.at[firsts[start], 'end'] == 'optional':
                    return [lines[start]] + split2blocks(start + 1)
                end = len(lines)
            return ['\n'.join(lines[start : end + 1])] + split2blocks(end + 1)

        return [PetsInputElement.from_any(block) for block in split2blocks(0)]

    def has_end(self):
        return (
            len(self.keywords) == 1
            and self.keywords[0] in pets_keywords.list
            and pets_keywords.table.at[self.keywords[0], 'end'] != 'false'
        )

    def build_string(self):
        if len(self.keywords) > 1:
            warn(f'Building `str(PetsInputElement)` with >1 keywords! {self.keywords}')
        prefix = [self.keywords[0]]
        delimiter = '\n' if (has_end := self.has_end()) else ' '
        suffix = [f'end{self.keywords[0]}'] if has_end else []
        return delimiter.join(str(s) for s in prefix + self.values + suffix)


AnyPetsInputElement = Union[PetsInputElement, str]


class PetsInputFactory:
    """Compile a PETS / PETS2 input file while preventing duplicates.

    This class is a general replacement for a simple print-to-file mechanism
    used previously. Using a list of all PETS2-viable keywords, it parses
    input strings and remembers all added commands. In addition to hard-coded
    parameters, it includes `config.camera.pets_prefix` (at the beginning)
    and `config.camera.pets_suffix` (at the end of the file). When a duplicate
    `PetsInputElement` is to be added, it is ignored and a warning is raised.
    """

    @classmethod
    def get_prefix(cls) -> Union[str, None]:
        return getattr(config.camera, 'pets_prefix', None)

    @classmethod
    def get_suffix(cls) -> Union[str, None]:
        return getattr(config.camera, 'pets_suffix', None)

    @classmethod
    def get_title(cls) -> str:
        return dedent(f"""
        # PETS input file for Electron Diffraction generated by `instamatic`
        # {str(ctime())}
        # For definitions of input parameters, see: https://pets.fzu.cz/
        """).strip()

    def __init__(self, elements: Optional[Iterable[AnyPetsInputElement]] = None) -> None:
        """As the input is built as we add, store current string & keywords."""
        self.current_elements: list[PetsInputElement] = []
        self.current_keywords: list[str] = []
        if elements is not None:
            for element in elements:
                self.add(element)

    def __add__(self, other: Self) -> Self:
        new = deepcopy(self)
        for element in other.current_elements:
            new.add(element)
        return new

    def __str__(self) -> str:
        return '\n'.join(str(e) for e in self.current_elements)

    def add(self, element: AnyPetsInputElement, *values: Any) -> None:
        """Add a PETS kw/values, a '# comment', or a text to be parsed."""
        if values or not isinstance(element, PetsInputElement):
            element = PetsInputElement.from_any(element, list(values))
        if self._no_duplicates_in(element.keywords):
            self.current_elements.append(element)

    def compile(self, image_converter_attributes: dict) -> Self:
        """Build a full version of PETS input with title, prefix, suffix."""
        pets_element_list = [self.get_title()]

        if (prefix := self.get_prefix()) is not None:
            if image_converter_attributes is not None:
                prefix = partial_formatter.format(prefix, **image_converter_attributes)
            pets_element_list.extend(PetsInputElement.list_from_text(prefix))

        pets_element_list.extend(self.current_elements)

        if (suffix := self.get_suffix()) is not None:
            if image_converter_attributes is not None:
                suffix = partial_formatter.format(suffix, **image_converter_attributes)
            pets_element_list.extend(PetsInputElement.list_from_text(suffix))

        return self.__class__(pets_element_list)

    def _no_duplicates_in(self, keywords: Iterable[str]) -> bool:
        """Return True & add keywords if there are no duplicates; else warn."""
        no_duplicates = True
        for keyword in keywords:
            if keyword in self.current_keywords:
                warn(f'Duplicate keyword rejected: {keyword}', PetsInputWarning)
                no_duplicates = False
        if no_duplicates:
            self.current_keywords.extend(list(keywords))
        return no_duplicates


if __name__ == '__main__':
    # check pets input added from config.camera.pets_prefix and _suffix only
    pif = PetsInputFactory().compile({})
    print('PETS DEFAULT INPUT (`config.camera.pets_prefix` + `suffix`:')
    print('---')
    print(str(pif))
    print('---')
    print(f'FOUND KEYWORDS: {{{", ".join(pif.current_keywords)}}}')
